!* ========================================================================== *
!*                                                                            *
!* Copyright (C) 2020 Intel Corporation                                       *
!* This file is part of the DMR library.                                      *
!*                                                                            *
!* For information on the license, see the LICENSE file.                      *
!* Further information: https://github.com/giacrossi/dmr/                     *
!* SPDX-License-Identifier: BSD-3-Clause                                      *
!*                                                                            *
!* ========================================================================== *
!* Giacomo Rossi (Intel Corporation)                                          *
!* ========================================================================== *

submodule (dmr) dmr_correctly_mapped
   use, intrinsic :: iso_c_binding
   use omp_lib
   use dmr_environment
   use dmr_c_functions

   implicit none

   contains
{% print("") %}
#if defined _F2018
{%- for t in types %}
      ! DMR Correctly Mapped {{keywords[t][0]}} F2018 Routines
{%- for p in kinds[t] %}
{%- if p.name == '128' %}
#if defined _real128
{%- endif %}
      module function omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}(array, omp_dev)
         implicit none
         logical                   :: omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}
         {{t}}({{keywords[t][2]}}{{p.key}}), intent(in)  :: array(..)
         integer(I4P), intent(in)  :: omp_dev
         integer(I4P), allocatable :: size_host(:)
         integer(I4P)              :: i, array_rank

         select rank(array_dst)
{%- for d in range(1,dimensions+1) %}
         rank({{d}})
            array_rank={{d}}
{%- endfor %}
         end select
         allocate(size_host(1:array_rank))
         do i=1, array_rank
            size_host(i) = size(array,i)
         enddo

         omp_correctly_mapped_{{keywords[t][1]}}{{p.name}} = .true.
!$omp target device(omp_dev) map(tofrom:omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}) map(to:size_host)
!$omp teams distribute parallel do reduction(.and.:omp_correctly_mapped_{{keywords[t][1]}}{{p.name}})
         do i=1, array_rank
            if (size(array,i)/=size_host(i)) omp_correctly_mapped_{{keywords[t][1]}}{{p.name}} = omp_correctly_mapped_{{keywords[t][1]}}{{p.name}} .and. .false.
         enddo
!$omp end teams distribute parallel do
!$omp end target
         deallocate(size_host)
      endfunction omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}
{%- if p.name == '128' %}
#endif
{%- endif %}
{% print("") %}
{%- endfor %}
{%- endfor %}

#else

{%- for t in types %}
      ! OpenMP Target Alloc {{keywords[t][0]}} Routines
{%- for p in kinds[t] %}
{%- if p.name == '128' %}
#if defined _real128
{%- endif %}
{%- for d in range(1,dimensions+1) %}
      module function omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}}(array, omp_dev)
         implicit none
         logical                   :: omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}}
         {{t}}({{keywords[t][2]}}{{p.key}}), intent(in){% if t=='real' and p.key=='16P' %}{% print('    ')%}{%- elif t=='complex' and p.key=='16P' %}{% print(' ')%}{%- elif t=='real' %}{% print('     ')%}{%- else %}{% print('  ')%}{%- endif %}:: array({% for dd in range(d) %}:{% if not loop.last %}, {%- endif %}{% endfor %})
{%- if d == 1 %}
         integer(I4P)              :: size_host
{%- else %}
         integer(I4P), parameter   :: array_rank={{d}}_I4P
         integer(I4P)              :: size_host({{d}})
{%- endif %}
         integer(I4P), intent(in)  :: omp_dev
         integer(I4P)              :: i
{% print("") %}
{%- if d == 1 %}
         size_host = size(array,1)
{%- else %}
         do i=1, array_rank
            size_host(i) = size(array,i)
         enddo
{%- endif %}

         omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}} = .true.
!$omp target device(omp_dev) map(tofrom:omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}}) map(to:size_host)
{%- if d == 1 %}
         if (size(array,1)/=size_host) omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}} = omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}} .and. .false.
{%- else %}
!$omp teams distribute parallel do reduction(.and.:omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}})
         do i=1, array_rank
            if (size(array,i)/=size_host(i)) omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}} = omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}} .and. .false.
         enddo
!$omp end teams distribute parallel do
{%- endif %}
!$omp end target
      endfunction omp_correctly_mapped_{{keywords[t][1]}}{{p.name}}_{{d}}
{% print("") %}
{%- endfor %}
{%- if p.name == '128' %}
#endif
{%- endif %}
{%- endfor %}
{% print("") %}
{%- endfor %}

#endif

endsubmodule dmr_correctly_mapped
